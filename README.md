# leetcode

## 数据结构类
### [1.数组 vector](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

* [704.二分查找](./docs/704.二分查找.md)
* [27.移除元素 - 双指针法](./docs/27.移除元素.md)
* [977.有序数组的平方](./docs/977.有序数组的平方.md)
* [209.长度最小的子数组 - 滑动窗口](./docs/209.长度最小的子数组.md)
* [59.螺旋矩阵II](./docs/59.螺旋矩阵II.md)

### [2.字符串 string](https://www.programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html#%E6%8B%93%E5%B1%95)

* [344.反转字符串 - 双指针法](./docs/344.反转字符串.md)
* [541.反转字符串II](./docs/541.反转字符串II.md)
* [替换空格](./docs/替换空格.md)
* [151.反转字符串中的单词](./docs/151.反转字符串中的单词.md)
* [左旋转字符串](./docs/左旋转字符串.md)
* [28.实现strStr() - KMP](./docs/28.实现strStr().md)
* [459.重复的子字符串](./docs/459.重复的子字符串.md)

### [3.链表 linkedlist](https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B)
* [203.移除列表元素](./docs/203.移除链表元素.md)
* [707.设计链表](./docs/707.设计链表.md)
* [206.反转链表 - 双指针法](./docs/206.反转链表.md)
* [24.两两交换链表中的节点](./docs/24.两两交换链表中的节点.md)
* [19.删除链表的倒数第N个结点 - 双指针法](./docs/19.删除链表的倒数第N个结点.md)
* [160.相交链表 - 双指针法](./docs/160.相交链表.md)
* [142.环形链表II - 双指针法](./docs/142.环形链表II.md)
* [23.合并K个升序链表](./docs/23.合并K个升序链表.md)

### [4.哈希表 hashmap](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

* [242.有效的字母异位词](./docs/242.有效的字母异位词.md)
* [349.两个数组的交集](./docs/349.两个数组的交集.md)
* [1.两数之和](./docs/1.两数之和.md)
* [383.赎金信](./docs/383.赎金信.md)
* [454.四数相加II](./docs/454.四数相加II.md)
* [15.三数之和 - 双指针法](./docs/15.三数之和.md)
* [18.四数之和 - 双指针法](./docs/18.四数之和.md)

### [5.栈和队列 stack queue](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)
* [232.用栈实现队列](./docs/232.用栈实现队列.md)
* [225.用队列实现栈](./docs/225.用队列实现栈.md)
### [6.二叉树 binary tree](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)
* [二叉树的前序/中序/后序/层序遍历](./docs/二叉树的遍历.md)
* [101.对称二叉树](./docs/101.对称二叉树.md)

## 算法类

### 1.排序和查找算法
* [十大经典排序算法](https://sort.hust.cc/)
    * 冒泡排序
    * 选择排序
    * 插入排序
    * 希尔排序
    * 归并排序
    * 快速排序
    * 堆排序
    * 计数排序
    * 桶排序
    * 基数排序
* 查找算法
    * 顺序查找
    * [704.二分查找](./docs/704.二分查找.md)

### [2.双指针法](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html)

* [27.移除元素](./docs/27.移除元素.md)
* [344.反转字符串](./docs/344.反转字符串.md)
* [替换空格](./docs/替换空格.md)
* [151.反转字符串中的单词](./docs/151.反转字符串中的单词.md)
* [206.反转链表](./docs/206.反转链表.md)
* [19.删除链表的倒数第N个结点](./docs/19.删除链表的倒数第N个结点.md)
* [160.相交链表](./docs/160.相交链表.md)
* [142.环形链表II](./docs/142.环形链表II.md)
* [15.三数之和](./docs/15.三数之和.md)
* [18.四数之和](./docs/18.四数之和.md)

##### 自己练习
* [763.划分字母区间](./docs/763.划分字母区间.md)

### [3.回溯（撤销回退）算法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB)

* [77.组合](./docs/77.组合.md)
* [39.组合总和](./docs/39.组合总和.md)
* [131.分割回文串](./docs/131.分割回文串.md)
* [78.子集](./docs/78.子集.md)
* [51.N皇后](./docs/51.N皇后.md)

### [4.贪心（局部最优推出全局最优）算法](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

### [5.动态规划](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

* [509.斐波那契数](./docs/509.斐波那契数.md)
* [70.爬楼梯](./docs/70.爬楼梯.md)
* [746.使用最小花费爬楼梯](./docs/746.使用最小花费爬楼梯.md)
* [62.不同路径](./docs/62.不同路径.md)
* [63.不同路径II](./docs/63.不同路径II.md)
* [343.整数拆分](./docs/343.整数拆分.md)
* [96.不同的二叉搜索树](./docs/96.不同的二叉搜索树.md)
* [背包问题](./docs/背包问题.md)
* [416.分割等和子集](./docs/416.分割等和子集.md)
* [322.零钱兑换](./docs/322.零钱兑换.md)
* [279.完全平方数](./docs/279.完全平方数.md)
* [139.单词拆分](./docs/139.单词拆分.md)
* [198.打家劫舍](./docs/198.打家劫舍.md)
* 子序列问题
    * [300.最长递增子序列](./docs/300.最长递增子序列.md)
    * [53.最大子数组和](./docs/53.最大子数组和.md)

### [6.单调栈](https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### [7.图论](https://programmercarl.com/other/tulunshuoming.html)

# [leetcode 热题100](https://leetcode.cn/studyplan/top-100-liked/)

#### 哈希
* [1.两数之和](./docs/1.两数之和.md)
* [49.字母异位词分组](./docs/49.字母异位词分组.md)
* [128.最长连续序列](./docs/128.最长连续序列.md)

#### 双指针
* [283.移动零](./docs/283.移动零.md)
* [11.盛最多水的容器](./docs/11.盛最多水的容器.md)
* [15.三数之和 - 双指针法](./docs/15.三数之和.md)
* [42.接雨水](./docs/42.接雨水.md)

#### 滑动窗口
* [3.无重复字符的最长子串](./docs/3.无重复字符的最长子串.md)
* [438.找到字符串中所有字母异位词](./docs/438.找到字符串中所有字母异位词.md)

#### 子串
* [560.和为K的子数组](./docs/560.和为K的子数组.md)

#### 普通数组
* [53.最大子数组和](./docs/53.最大子数组和.md)
* [56.合并区间](./docs/56.合并区间.md)

#### 链表
* [160.相交链表](./docs/160.相交链表.md) 
* [206.反转链表](./docs/206.反转链表.md)
* [160.相交链表](./docs/160.相交链表.md) 
* [234.回文链表](./docs/234.回文链表.md)
* [141.环形链表](./docs/141.环形链表.md)
* [142.环形链表II](./docs/142.环形链表II.md)
* [21.合并两个有序链表](./docs/21.合并两个有序链表.md)
* [2.两数相加](./docs/2.两数相加.md)

#### 二叉树
* [104.二叉树的最大深度](./docs/104.二叉树的最大深度.md)
* [226.翻转二叉树](./docs/226.翻转二叉树.md)
* [二叉树的前序/中序/后序/层序遍历](./docs/二叉树的遍历.md)
* [101.对称二叉树](./docs/101.对称二叉树.md)
* [543.二叉树的直径](./docs/543.二叉树的直径.md)
* [108.将有序数组转换为二叉搜索树](./docs/108.将有序数组转换为二叉搜索树.md)

#### 贪心算法
* [121.买卖股票的最佳时机](./docs/121.买卖股票的最佳时机.md)

#### 动态规划
* [70.爬楼梯](./docs/70.爬楼梯.md)
* [118.杨辉三角](./docs/118.杨辉三角.md)
* [198.打家劫舍](./docs/198.打家劫舍.md)
* [279.完全平方数](./docs/279.完全平方数.md)
* [322.零钱兑换](./docs/322.零钱兑换.md)
* [139.单词拆分](./docs/139.单词拆分.md)
* [300.最长递增子序列](./docs/300.最长递增子序列.md)
* [152.乘积最大子数组](./docs/152.乘积最大子数组.md)
* [416.分割等和子集](./docs/416.分割等和子集.md)
* [1143.最长公共子序列](./docs/1143.最长公共子序列.md)

#### 回溯
* [46.全排列](./docs/46.全排列.md)
* [78.子集](./docs/78.子集.md)
* [131.分割回文串](./docs/131.分割回文串.md)

#### 技巧
* [136.只出现一次的数字](./docs/136.只出现一次的数字.md)
* [169.多数元素](./docs/169.多数元素.md)
* [75.颜色分类](./docs/75.颜色分类.md)

# [面试经典 150 题](https://leetcode.cn/studyplan/top-interview-150/)
#### 双指针
* [125.验证回文串](./docs/125.验证回文串.md)

## 刷题记录（11.06-）
加*表示做得不好，下次重练

#### 11.06
*[136.只出现一次的数字](./docs/136.只出现一次的数字.md)
[169.多数元素](./docs/169.多数元素.md)
[75.颜色分类](./docs/75.颜色分类.md)
[70.爬楼梯](./docs/70.爬楼梯.md)
*[118.杨辉三角](./docs/118.杨辉三角.md)
[198.打家劫舍](./docs/198.打家劫舍.md)
[2.两数相加](./docs/2.两数相加.md)

#### 11.07
[二叉树的前序/中序/后序/层序遍历](./docs/二叉树的遍历.md)

#### 11.08
[141.环形链表](./docs/141.环形链表.md)
[142.环形链表II](./docs/142.环形链表II.md)
[198.打家劫舍](./docs/198.打家劫舍.md)
*[279.完全平方数](./docs/279.完全平方数.md)
*[322.零钱兑换](./docs/322.零钱兑换.md)
*[139.单词拆分](./docs/139.单词拆分.md)
*[300.最长递增子序列](./docs/300.最长递增子序列.md)
[46.全排列](./docs/46.全排列.md)
[78.子集](./docs/78.子集.md)
*[131.分割回文串](./docs/131.分割回文串.md)

#### 11.09
[125.验证回文串](./docs/125.验证回文串.md)

#### 02.01
哈希-49.字母异位词分组
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> umap;

        for (string s:strs){
            string key = s;
            sort(key.begin(), key.end());
            umap[key].push_back(s);
        }

        for (auto it=umap.begin(); it != umap.end(); it++){
            res.push_back(it->second);
        }
        return res;
    }
};
```
哈希-128. 最长连续序列
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty()) return 0;
        if (nums.size()==1) return 1;
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(),nums.end()), nums.end());
        // 去重排序
        int res = 1;
        int pre = nums[0];
        vector<int> ress;
        for (int i = 1; i < nums.size(); i++){
            if (nums[i] - pre == 1) res++;
            else {
                ress.push_back(res);
                res = 1;
            }
            pre = nums[i];
        }
        int fres;
        if (ress.empty()) fres = res;
        else {
            ress.push_back(res);
            auto it = max_element(ress.begin(),ress.end());
            fres = *it;
        }
        return fres;
    }
};
```

#### 02.04
哈希-1.两数之和
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap;
        for (int i = 0; i < nums.size(); i++){
            auto it = umap.find(target - nums[i]);
            if (it != umap.end()) return {i, it->second};
            else umap.insert(pair<int,int>(nums[i], i));
        }
        return {};
    }
};
```
哈希-49.字母异位词分组

哈希-128. 最长连续序列
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        //最好先排序+去重
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        vector<int> ress;
        if (nums.empty()) return 0;
        if (nums.size()==1) return 1;

        int res = 1;
        int num = nums[0];
        vector<int> nums2(nums.begin()+1, nums.end());
        for (int i:nums2){
            if (i-num == 1) res++;
            else res = 1;
            ress.push_back(res);
            num = i;
        }
        auto it = max_element(ress.begin(), ress.end());
        return *it;
    }
};
```
双指针-283.移动零
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++){
            if (!nums[i]){
                nums.erase(nums.begin()+i);
                i--;// 删完一个0，数组长度减1，索引相应减1
                cnt++;
            }
        }
        while(cnt--){
            nums.push_back(0);
        }
        return;
    }
};

// 交换
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++){
            if (nums[i]!=0) continue;
            else{
                int offset = 1;
                int j = i + offset;
                while(j < nums.size() && nums[j]==0){
                    offset++;
                    j = i+offset;//i+2
                }
                if (j < nums.size()) 
                    swap(nums[i], nums[j]);//1 0 0 0 0 0
            }
        }
        return;
    }
};
```

#### 02.12
滑动窗口-438.找到字符串中所有字母异位词
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        vector<int> res;
        int shash[26] = {0}; // 或 std::vector<int> pcnt(26), scnt(26);
        int phash[26] = {0};
        for (int i = 0; i < p.size(); i++){
            shash[s[i]-'a']++;
            phash[p[i]-'a']++;
        }
        if (equal(begin(shash), end(shash), begin(phash))) res.push_back(0);
        for (int i = 0; i < s.size()-p.size();i++){
            shash[s[i]-'a']--;
            shash[s[i+p.size()]-'a']++;
            if (equal(begin(shash), end(shash), begin(phash))) res.push_back(i+1);
        }
        return res;
    }
};
```
超时做法
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size()) return res;
        sort(p.begin(), p.end());
        int start = 0;
        for (;start < s.size();start++){
            string subs = s.substr(start,p.size());
            sort(subs.begin(), subs.end());
            if (p==subs) res.push_back(start);
        }
        return res;
    }
};
```

#### 02.13
链表-2.两数相加
```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode*head = nullptr, *tail = nullptr;
        int quo=0, num1, num2, sum;
        while(l1||l2){
            num1=l1?l1->val:0;
            num2=l2?l2->val:0;
            sum=num1+num2+quo;
            quo=sum/10;
            if(!head)head=tail=new ListNode(sum%10);
            else{
                tail->next=new ListNode(sum%10);
                tail=tail->next;
            }
            if(l1)l1=l1->next;
            if(l2)l2=l2->next;
        }
        if(quo) tail->next = new ListNode(quo);
        return head;
    }
};
```

## C++刷题小抄

unordered_set：
```cpp
uset.insert(i); //uset插入
for (auto it = uset.begin(); it != uset.end(); it++) cout << *it << " "; //uset遍历
```
vector中求最大元素：
```cpp
auto it = max_element(vec.begin(), vec.end());
cout << *it;
```

vector 首元素/末元素的引用
```cpp
vector<int> s = {1,2,4,3};
s.front() = 999;//等于s[0]
s.back() = 888;//等于s[s.size()-1]
```

判断vector是否为空:
```cpp
bool vec.empty()
```
vector 去重：
```cpp
sort(vec.begin(), vec.end());
vec.erase(unique(vec.begin(), vec.end()), vec.end());
```

通过迭代器实现vector 切片：
```cpp
vector<int> s = {1,2,4,3};
auto begin = s.begin()+1; 
auto end = s.end()-1; 
vector<int> s2(begin, end);//此处不是等号，是构造函数
```

vector 删除指定的元素
```cpp
vector<int> s = {1,2,4,3};
s.erase(s.begin() + 0);//删除第一个元素1
```

vector和array按固定长度5初始化
```cpp
vector<int> s(5, 0); 等效于 vector<int> s(5); //正确vector<int> s= {1,2,3,4,5}; 错误写法vector<int> s(5) = {1,2,3,4,5};
int s[5] = {1,2,3,4,5};
int s[5] = {0};
```

求原生数组的长度
```cpp
int s[5] = {1,2,3,4,5};
int length = sizeof(s) / sizeof(s[0]);
```

对比原生数组 `int s[5]`，数组 `std::array`，向量 `std::vector`，字符串 `std::string`的区别
```
1.原生数组没有成员函数或方法，对数组的操作通常需要使用标准库或手动编写代码
  数组array是标准库容器，可调用封装好的成员函数和方法
2.向量vector是动态数组，提供了方便的动态调整大小和元素操作的功能
  数组array是静态数组，长度固定，不能动态调整，但在长度已知的情况下，访问速度较快
3.字符串string实际是基于向量vector实现的动态数组，继承了vector的动态调整大小的特性以适应字符串的长度变化，在处理字符串时更加灵活和方便
```

string 中根据索引选出子串
```cpp
string s = "Hello, World!";
string ss = s.substr(startIndex, length);
```

数组不能直接用数组名比较大小
```cpp
//数组名表示指向数组首元素的指针 a==b恒为0
int a[3] = {0}, b[3] = {0};
bool x = equal(begin(a), end(a), begin(b));
```

## 刷题方式
第一阶段按照 tag 去刷， 第二阶段则要一题多解，多题同解，挖掘题目背后的东西

去年找互联网的工作，刷了两遍LeetCode，只做了前200道。面试过程中碰到的算法题基本都被秒杀了。最后拿了9个offer。我是按Tag来刷的。链表，二叉树，回溯，深度宽度优先遍历，图，贪心，动规，数组，哈希表……每个tag由easy到hard，每道题先自己思考，不会的参考了一个开源的解答或者参考Discuss或者博客。开始的时候自己独立思考的时间比较长，后来没了耐心，不会的题目就马上看解答了。一般题目解法有多种，这时候最好尝试一下其他的做法，至少要知道思路。比如有关图的题目就会有DFS和BFS两种解法。Discuss里一般都会有高质量的解答。关键是每道题都要弄明白。一开始用IDE，跑出正确结果，再在线默写代码。后来写的多了，直接在线写代码了。这是一个自然的过程，做的多了就有“手感”了。总结一下，按tag由易到难，每道题弄清楚，知道其他的解法，这是核心！搞定了核心，

前200题是最经典的。前期可以先积累量，把前两百题刷完 刷够量之后，对算法有了一个大概的理解。然后再精刷。最好先按tag刷。分类总结下自己需要刷的tag。然后按出现频率排序，再按这个顺序刷。最后面试前再刷要面试的那个公司的高频题。

分享一下身边大神的刷题顺序：

如果你时间比较紧迫，为了找工作而刷题，我建议你先刷热门推荐，一共两百多道题。

在 https://leetcode-cn.com/problemset/all/ 页面的右侧。先刷热题 HOT 100，再刷精选 TOP 面试题，之后刷其他的题。如果你时间比较充裕，那我建议你：按从低到高的难度分组刷按 tag 分类刷定期复习，重做之前刷过的题

刷题方法：

第一遍：可以先思考，之后看参考答案刷，结合其他人的题解刷。思考、总结并掌握本题的类型，思考方式，最优题解。

第二遍：先思考，回忆最优解法，并与之前自己写过的解答作比对，总结问题和方法。

第三遍：提升刷题速度，拿出一个题，就能够知道其考察重点，解题方法，在短时间内写出解答。定期总结：按照题目类型进行总结：针对一类问题，总结有哪些解题方法，哪种方法是最优的，为什么。总结重点：有些题你刷了好多遍都还是不会，那就要重点关注，多思考解决方法，不断练习强结合图解刷题：有些人认为刷题比较枯燥，比较抽象。那你可以结合动画图解刷题。


## 有用网址
[别人总结好的力扣合集](https://github.com/stevenli91748/Data-Structure-and-Algorithmic)

[刷leetcode（力扣）不知道从哪里刷起？？代码随想录，你值得拥有](https://zhuanlan.zhihu.com/p/339849416)

## 题解
[Blind75Cpp题解](https://github.com/ldtech007/leetcode) [在线文档](https://docs.qq.com/sheet/DWGJZdmZSQUJvWWp3)

[网友自己Cpp题解](https://github.com/pezy/LeetCode)

## 资源使用路线
原理讲解+简洁：[hello-algo](https://github.com/krahets/hello-algo) 配套习题：[图解算法数据结构](https://github.com/krahets/LeetCode-Book)

按数据结构算法分类+简洁+Cpp：[LeetCode 101](https://github.com/changgyhub/leetcode_101)

按难度分类：[力扣加加](https://github.com/azl397985856/leetcode)

按数据结构算法分类+视频讲解：[代码随想录](https://github.com/youngyangyang04/leetcode-master)

---

按数据结构算法分类+英文+简洁：[LeetCode题解bysoulmachine](https://github.com/soulmachine/leetcode)

有点花哨重在理解技巧：[labuladong](https://github.com/labuladong/fucking-algorithm)

Go版本可参考刷题列表：[1.LeetCode Cookbook](https://github.com/halfrost/LeetCode-Go) [2.算法竞赛模板库by灵茶山艾府](https://github.com/EndlessCheng/codeforces-go)